<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dict>
    <entry key="blockstrategy">
        <dict>
            <entry key="name">
                <string>net.postchain.base.BaseBlockBuildingStrategy</string>
            </entry>
        </dict>
    </entry>
    <entry key="configurationfactory">
        <string>net.postchain.gtx.GTXBlockchainConfigurationFactory</string>
    </entry>
    <entry key="gtx">
        <dict>
            <entry key="modules">
                <array>
                    <string>net.postchain.rell.module.RellPostchainModuleFactory</string>
                    <string>net.postchain.gtx.StandardOpsGTXModule</string>
                </array>
            </entry>
            <entry key="rell">
                <dict>
                    <entry key="modules">
                        <array>
                            <string></string>
                        </array>
                    </entry>
                    <entry key="sources_v0.10">
                        <dict>
                            <entry key="main.rell">
                                <string>import storage;</string>
                            </entry>
                            <entry key="storage/index.rell">
                                <string>@external('filehub') @log
entity blockchain { 
	key rid: byte_array;
}

@external('filehub') @log
entity chunk {
	key hash: byte_array;
	pubkey;
	blockchain;
}

entity stored_file {
	key hash: byte_array;
	transaction;
}

struct gtx_operation {
    name;
    args: list&lt;gtv&gt;;
}
struct gtx_transaction {
     operations: list&lt;gtx_operation&gt;;
}</string>
                            </entry>
                            <entry key="storage/operations.rell">
                                <string>operation add_chunk_data (data: byte_array) {
   val hash = data.sha256();
   val chunk = chunk @ { hash };
   require(chunk.blockchain.rid == chain_context.blockchain_rid); // TODO: this won't work now, can be done using module_args instead
   
   // Verify that the same user stores the data, that paid for it
   require(is_signer(chunk.pubkey));
   
   create stored_file(hash, op_context.transaction);
}

operation remove_chunk_data(data: byte_array) {
	val hash = data.sha256();
	val chunk = chunk@{ hash };
	
	require(is_signer(chunk.pubkey));
	delete stored_file@{ hash };
}</string>
                            </entry>
                            <entry key="storage/queries.rell">
                                <string>query get_chunk(hash: byte_array): gtv {
	val gtx_tx = gtx_transaction.from_bytes(stored_file@{ hash } ( .transaction.tx_data ));
	return gtx_tx.operations[0].args[0];	
}</string>
                            </entry>
                        </dict>
                    </entry>
                </dict>
            </entry>
        </dict>
    </entry>
    <entry key="signers">
        <array>
            <bytea>0350FE40766BC0CE8D08B3F5B810E49A8352FDD458606BD5FAFE5ACDCDC8FF3F57</bytea>
        </array>
    </entry>
</dict>
