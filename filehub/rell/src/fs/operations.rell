import ft3_acc: lib.ft3.account;
import util;
import admin;

operation allocate_file(descriptor_id: byte_array, file_hash: byte_array, total_bytes: integer) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
	
	ft3_acc.require_auth(account, descriptor_id, ["A"]);
	require(file_hash.size() < 256, "File hash isn't allowed to be longer than 256");
	
	val current_timestamp = op_context.last_block_time;
	
	val file = file @? { file_hash } limit 1;
	require(file == null, "[OK] File already stored");
	
	create file(
		file_hash, 
		timestamp = op_context.last_block_time, 
		allocated_size = total_bytes
	);
}

operation allocate_chunk(descriptor_id: byte_array, file_hash: byte_array, chunk_hash: byte_array, chunk_size: integer, idx: integer) {
	log("allocate_chunk");
	val account = util.get_account_by_descriptor_id(descriptor_id);
	
	ft3_acc.require_auth(account, descriptor_id, ["A"]);
	require(chunk_size < 1024 * 1024, "Chunk must be less than a mb");
	
	val file = file @ { file_hash };
	
	val allocated_size = (fc: file_chunk, cs: chunk_size) @ { 
		fc.file == file,
		fc.chunk == cs.chunk
	} ( @sum cs.size );
	
	require(allocated_size + chunk_size <= file.allocated_size, "No more space allocated for file");
	require(file_chunk @? { file, idx } == null, "[OK] No work to be done");
		
	var chunk = (active: active_filechain, file_chunk) @? {
		file_chunk.chunk.hash == chunk_hash,
		file_chunk.filechain == active.filechain
	} ( file_chunk.chunk ) limit 1;
		
	val chain = chain_selector(idx);
	
	if (chunk == null) {
		chunk = create chunk(chunk_hash, chain);
	}
	
	create file_chunk(file, idx, chain, chunk);
	create chunk_size(chunk, chunk_size);
}

operation delete_file(hash: byte_array) {
	val file = file @ { hash };
	delete file_chunk @* { file };
}