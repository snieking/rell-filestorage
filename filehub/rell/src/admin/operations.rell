import util;
import storage;
import billing;
import ft3_acc: lib.ft3.account;
import ft3_core: lib.ft3.core;

operation add_filechain_application(descriptor_id: byte_array, brid: byte_array, node_url: text, source_code: text) {
	require(storage.filechain@?{ brid } == null, "Brid is already in-use");
	
	val account = util.get_account_by_descriptor_id(descriptor_id);
	billing.charge_chromia_tokens(descriptor_id, account, 100);
	create filechain_application(account, brid, node_url = node_url, source_code = source_code);
}

operation approve_filechain_application(descriptor_id: byte_array, brid: byte_array) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
    require(admin@?{ account } != null, "User not an admin");
    
    val application = filechain_application@{ brid };
    val filechain = create storage.filechain(brid);
    create storage.active_filechain(filechain, billing.plan.COMMON, op_context.last_block_time, application.account);
    delete application;
}

operation reject_filechain_application(descriptor_id: byte_array, brid: byte_array) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
    require(admin@?{ account } != null, "User not an admin");
    
    val application = filechain_application@{ brid };
    create payout(application.account.id, 100);
    delete application;
}

operation add_chromia_filechain(descriptor_id: byte_array, rid: byte_array) {
    val account = util.get_account_by_descriptor_id(descriptor_id);
    require(admin@?{ account } != null, "User not an admin");

    if (storage.filechain@?{ rid } == null) {
    	log("Adding filechain with brid: ", rid);
        val filechain = create storage.filechain(rid);
        create storage.active_filechain(filechain, billing.plan.CHROMIA, op_context.last_block_time, account);
	}
}

operation disable_filechain(descriptor_id: byte_array, rid: byte_array) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
	log("Disabling filechain with brid: ", rid);
		
	val the_filechain = storage.active_filechain@{ .filechain.brid == rid, account };
	
	require(
		storage.active_filechain@?{ .filechain.brid != rid, .plan == the_filechain.plan } != null, 
		"There must be another filechain active of type: " + the_filechain.plan
	);
	
	create storage.disabled_filechain(
		the_filechain.filechain, 
		the_filechain.plan, 
		the_filechain.account, 
		op_context.last_block_time
	);
	
    delete the_filechain;
}

operation register_admin(descriptor_id: byte_array) {
    if (admin@?{} == null) {
        val account = util.get_account_by_descriptor_id(descriptor_id);
        create admin(account);
    }
}

operation handle_payouts(descriptor_id: byte_array) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
    require(admin@?{ account } != null, "User not an admin");
    ft3_acc.require_auth(account, descriptor_id, ["T"]);
    
	val asset = ft3_core.asset@{ .id == ("CHR", chain_context.blockchain_rid).hash() };
    
    val payouts = payout@*{};
    for (p in payouts) {
    	val xfer_input = ft3_core.xfer_input(account_id = account.id, asset_id = asset.id, auth_descriptor_id = descriptor_id, p.amount, map<text, gtv>());
		val xfer_output = ft3_core.xfer_output(account_id = p.account_id, asset_id = asset.id, p.amount, map<text, gtv>());
	
		ft3_core._transfer([xfer_input], [xfer_output]);
    }
}