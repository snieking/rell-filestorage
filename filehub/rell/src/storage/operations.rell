import ft3_acc: lib.ft3.account;
import util;
import billing;

operation allocate_chunk(descriptor_id: byte_array, name, hash: byte_array, file_size: integer) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
	ft3_acc.require_auth(account, descriptor_id, ["A"]);
	require(name.size() < 256, "Length of a name isn't allowed to be longer than 256");
	
	var chunk = chunk@?{ hash };
	
	if (chunk == null) {
	    val filechain = filechain@{}; // choose a blockchain
		
		// Check if user has active voucher
		val current_timestamp = op_context.last_block_time;
		
		val active_voucher = billing.voucher@?{ account, .timestamp > current_timestamp } (
			@sort_desc .timestamp,
			.plan,
			.asset,
			.amount
		) limit 1;
		
		require(active_voucher, "User must have an active invoice");
		require(util._get_allowed_storage_bytes(active_voucher.plan) >= _get_allocated_bytes(account) + file_size, "Not enough storage left for user");
		chunk = create chunk(hash, filechain);			
	}
	
	create chunk_meta(account, chunk, name);
	
	val chunk_size = chunk_size@?{ .chunk == chunk };
	
	if (chunk_size != null) {
		require(chunk_size.size == file_size, "Chunk size doesn't match provided file_size");
	} else {
		create chunk_size(chunk, file_size);
	}
}

operation deallocate_chunk(descriptor_id: byte_array, hash: byte_array) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
	ft3_acc.require_auth(account, descriptor_id, ["A"]);
	delete chunk_meta@{ account, chunk@{ hash } };
}