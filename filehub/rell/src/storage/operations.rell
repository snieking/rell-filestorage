import ft3_acc: lib.ft3.account;
import util;
import billing;
import admin;

operation allocate_file(descriptor_id: byte_array, name, total_bytes: integer, plan_to_use: text) {
	log("allocate_file for plan: ", plan_to_use);
	val account = util.get_account_by_descriptor_id(descriptor_id);
	
	ft3_acc.require_auth(account, descriptor_id, ["A"]);
	require(name.size() < 256, "Length of a name isn't allowed to be longer than 256");
	
	val plan = billing.text_to_plan(plan_to_use);
	val current_timestamp = op_context.last_block_time;	
	verify_voucher(account, plan, current_timestamp, total_bytes);
	
	create file(name, account, chain_selector(plan), current_timestamp, plan);
}

operation allocate_chunk(descriptor_id: byte_array, name, hash: byte_array, chunk_size: integer, idx: integer) {
	log("allocate_chunk");
	val account = util.get_account_by_descriptor_id(descriptor_id);
	
	ft3_acc.require_auth(account, descriptor_id, ["A"]);
	require(name.size() < 256, "Length of a name isn't allowed to be longer than 256");
	require(chunk_size < 1024 * 1024, "Chunk must be less than a mb");
	
	val file = file@{ name, account };
	
	val matching_chunks = chunk@*{ hash };
	
	var chunk = (chunk, active_filechain)@?{
		chunk.hash == hash,
		chunk.filechain == active_filechain.filechain
	} ( chunk ) limit 1;
	
	if (chunk == null) {
		val current_timestamp = op_context.last_block_time;
		
		verify_voucher(account, file.plan, current_timestamp, chunk_size);
		chunk = create chunk(hash, file.filechain);			
	}
	
	create file_chunk(file@{ name, account }, chunk, idx, timestamp = op_context.last_block_time);
	
	val stored_size = chunk_size@?{ .chunk == chunk } limit 1;
	
	if (stored_size != null) {
		require(stored_size.size == chunk_size, "Chunk size doesn't match provided file_size");
	} else {
		create chunk_size(chunk, chunk_size);
	}
}

operation deallocate_file(descriptor_id: byte_array, name) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
	ft3_acc.require_auth(account, descriptor_id, ["A"]);
	
	val file = file@{ name, account };
	delete file_chunk@*{ file };
	delete file;
}

operation migrate_file(descriptor_id: byte_array, name, timestamp, from_chain: byte_array) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
	
	val disabled_filechain = disabled_filechain@{ .filechain.brid == from_chain, account };	
	
	val old_files = file@*{ name, timestamp, disabled_filechain.filechain };
	
	log("Old files for name: ", name, old_files);
	
	val filechain = chain_selector(disabled_filechain.plan);
	
	for (old_file in old_files) {
		val file_chunks = file_chunk@*{ old_file };
		log("File chunks for file", old_file);
		
		val new_file = create file(old_file.name, old_file.account, filechain, op_context.last_block_time, old_file.plan);
		
		for (file_chunk in file_chunks) {
			log("Creating chunk with hash: ", file_chunk.chunk.hash, " in filechain: ", filechain.brid, " for filename: ", name);
			
			var chunk = chunk@?{ file_chunk.chunk.hash, filechain };
			
			if (chunk == null) {
				chunk = create chunk(file_chunk.chunk.hash, filechain);
				val old_chunk_size = chunk_size@{ file_chunk.chunk };
				create chunk_size(chunk, old_chunk_size.size);
			}
			
			create file_chunk(new_file, idx = file_chunk.idx, chunk, timestamp = op_context.last_block_time);
		}
	}
}

operation mark_file_migrated(descriptor_id: byte_array, name, timestamp, from_chain: byte_array) {
	val account = util.get_account_by_descriptor_id(descriptor_id);
	val disabled_filechain = disabled_filechain@{ .filechain.brid == from_chain, account };	
	
	val files = file@*{ name, timestamp, disabled_filechain.filechain };
	
	for (file in files) {
		delete file_chunk@* { file };
		delete file;
	}
}

function chain_selector(billing.plan): filechain {
	log("Selecting chain for plan: ", plan);
	return active_filechain@{ plan } ( .filechain, @omit @sort_desc .timestamp ) limit 1;
}

function verify_voucher(ft3_acc.account, billing.plan, timestamp, file_size: integer) {
	val active_voucher = billing.voucher@?{ 
		account, 
		plan == plan,
		.timestamp > timestamp
	} (
		@sort_desc .timestamp,
		.plan,
		.asset,
		.amount
	) limit 1;
	
	require(active_voucher, "User must have an active invoice");
	require(util._get_allowed_storage_bytes(active_voucher.plan) >= _get_allocated_bytes(account) + file_size, "Not enough storage left for user");
}